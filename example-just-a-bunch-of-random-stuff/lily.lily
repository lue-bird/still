

choice tree A
    | Leaf A
    | Branch vec (tree A)

tree-size \:tree A:tree >
    tree
    | :tree A:Branch :vec (tree A):subs >
        vec-length subs
    | :tree A:Leaf :A:_ >
        1

choice int-cons-list
    | Empty
    | Cons { head int, tail int-cons-list }

# My docs
# can span multiple lines
#
greet \{ name :str:name } >
    = list
        [ "1", "2", "3" ]
    = another
        vec-attach list
            list
    name
    | "me" >
        "Hello, you!"
    | :str:_ >
        strs-flatten (vec-attach [ "Hello, ", name, "!" ] another)

unfinished
    [ unt-to-str 3
    ]

build-tree \:unt:n >
    int-to-unt (int-add (unt-to-int n) -1)
    | :opt unt:Absent > :tree {}:Leaf {}
    | :opt unt:Present :unt:remaining >
        :tree {}:Branch [ build-tree remaining ]

choice result Ok Err
    | Ok Ok
    | Err Err

closure-requiring-clone-of-capture \:vec int:variable >
    [ \:int:whatever > vec-attach variable [ whatever ]
    , \:int:another > vec-attach variable [ another ]
    ]

test-closure-impl
    vec-walk-from [ 0, 1, 3 ]
        0
        (\:unt:sum, :unt:element >
            :continue-or-exit unt unt:Continue unt-add sum element
        )

type state =
    unt

initial-state :state:0

interface \:state:state >
    { new-state unt-add state 1
    , standard-out-write unt-to-str state
    }

ansi-clear-screen
    "\u{1B}c"

run \:opt str:state-or-uninitialized >
    = state
        state-or-uninitialized
        | :opt str:Absent > ""
        | :opt str:Present :str:initialized > initialized
    :io str:Batch
        [ :io str:Standard-out-write
            strs-flatten
                [ ansi-clear-screen, state, "\nType a sentence to echo: " ]
        , :io str:Standard-in-read-line \:str:line > line
        ]

choice io Future
    | Standard-out-write str
    | Batch vec (io Future)
    | Standard-in-read-line \str > Future

book
    [ `Adam?
      `Can you believe this is happening?
      `I can't.
      `I'll pick you up.
      `Looking sharp.
      `Use the stairs, Your father paid good money for those.
      `Sorry. I'm excited.
      `Here's the graduate.
      `We're very proud of you, son.
      `A perfect report card, all B's.
      `Very proud.
      `Ma! I got a thing going here.
      `You got lint on your fuzz.
      `Ow! That's me!
      `Wave to us! We'll be in row 118,000.
    ]

choice rope
    | One str
    | Append { left rope, right rope }

rope-into \:str:builder, :rope:rope >
    rope
    | :rope:One "" >
        rope
    | :rope:One :str:_ >
        rope
    | :rope:Append { left :rope:left, right :rope:One "" } >
        rope-into builder left
    | :rope:Append { left :rope:left, right :rope:_ } >
        rope-into builder left

temporary-function
    = unused-function \:int:_ > 0
    2

function-taking-function \:\unt > unt:f >
    f 0

using-function-taking-function \:\unt > unt:f >
    function-taking-function f

function-taking-function-taking-function-taking-function \:\\\unt > unt > unt > unt:f >
    f (\:\unt > unt:g > g 0)

build-local-variables \:str:your-builder-string >
    = s str-attach-char your-builder-string ' '
    = s^ str-attach-unt s 10
    = s^ str-attach s " > "
    str-attach-dec s 10.2

build-single-matches \:str:your-builder-string >
    str-attach-char your-builder-string ' '
    | :str:s^ >
    str-attach-unt s 10
    | :str:s^ >
    str-attach s " > "
    | :str:s^ >
    str-attach-dec s 10.2

