cargo-features = ["codegen-backend"]
[package]
name = "still"
edition = "2024"
[[bin]]
name = "still"
path = "main.rs"

[dependencies]
compact_str = "0.9.0"
lsp-server = "0.7.9"
lsp-types = "0.95.1"
prettyplease = "0.2.37"
proc-macro2 = { version = "1.0.106", default-features = false }
serde_json = "1.0.145"
strongly-connected-components = "1.0.0"
syn = { version = "2.0.114", features = ["full"], default-features = false }

[profile.dev]
# speeds up build a ton (about 6-10+ times)
codegen-backend = "cranelift"
# speeds up build
debug = "none"
# >= 1 required to enable tail-call-elimination.
# Without, the language server stack can overflows on bigger files.
# Here, I chose to do 2 to get a more realistic feel for the release performance
# but please do switch to 1 locally if you need faster compile times
opt-level = 2

[profile.release]
# improves runtime speed by a few percent since the code doesn't unwind panics
panic = "abort"

[profile.profiling]
inherits = "release"
debug = true

[lints.rust]
unused_qualifications = { level = "warn" }
ambiguous-negative-literals = { level = "warn" }
unused_lifetimes = { level = "warn" }
trivial-numeric-casts = { level = "warn" }
# contains false positives when lifetime is used in impl
# single-use-lifetimes = { level = "warn" }

# If you want to contribute, you really don't need to bother with clippy
# I just wanted to try enabling it for myself to maybe find performance issues
[lints.clippy]
todo = { level = "warn" }
shadow_unrelated = { level = "warn" }
unused_trait_names = { level = "warn" }
ref-patterns = { level = "warn" }
int_plus_one = { level = "allow" }
question_mark = { level = "allow" }
items_after_statements = { level = "allow" }
match_like_matches_macro = { level = "allow" }
doc_markdown = { level = "allow" }

pedantic = { level = "warn", priority = -1 }
# might enable later, currently just annoying
type_complexity = { level = "allow" }
single_char_pattern = { level = "allow" }
# generally useful but too many false positives and cases where returning the same trivial expression is perfectly fine
match_same_arms = { level = "allow" }
# has false positives, e.g. for std::path::Path
unnecessary_debug_formatting = { level = "allow" }
redundant_field_names = { level = "allow" }
unwrap_or_default = { level = "allow" }
redundant_closure = { level = "allow" }
collapsible_else_if = { level = "allow" }
# heuristic
too_many_arguments = { level = "allow" }
# sometimes skip(length_of_thing).next is more clear
iter_skip_next = { level = "allow" }
too_many_lines = { level = "allow" }
uninlined_format_args = { level = "allow" }
explicit_iter_loop = { level = "allow" }
similar_names = { level = "allow" }
single_match_else = { level = "allow" }
map_unwrap_or = { level = "allow" }
if_not_else = { level = "allow" }
cast_possible_truncation = { level = "allow" }
cast_sign_loss = { level = "allow" }
cast_possible_wrap = { level = "allow" }
manual_string_new = { level = "allow" }
option_option = { level = "allow" }
elidable_lifetime_names = { level = "allow" }

nursery = { level = "warn", priority = -1 }
# not sure how to _only_ allow recursive self in type definitions?
use_self = { level = "allow" }
option_if_let_else = { level = "allow" }
missing_const_for_fn = { level = "allow" }
branches_sharing_code = { level = "allow" }
equatable_if_let = { level = "allow" }
useless_let_if_seq = { level = "allow" }
