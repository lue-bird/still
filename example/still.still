

choice tree A
    | Leaf A
    | Branch vec (tree A)

tree-size \:tree A:tree >
    tree
    | :tree A:Branch :vec (tree A):subs >
        vec-length subs
    | :tree A:Leaf :A:_ >
        1

choice int-cons-list
    | Empty
    | Cons { head int, tail int-cons-list }

# My docs
# can span multiple lines
#
greet \{ name :str:name } >
    let list
        [ 1, 2, 3 ]
    let another
        vec-attach list
            list
    name
    | "me" >
        "Hello, you!"
    | :str:_ >
        strs-flatten [ "Hello, ", name, "!" ]

unfinished
    [ int-to-str 3
    ]

build-tree \:int:n >
    n
    | 0 > :tree {}:Leaf {}
    | :int:not-0 >
        :tree A:Branch [ build-tree (int-add not-0 -1) ]

choice result Ok Err
    | Ok Ok
    | Err Err

closure-requiring-clone-of-capture \:vec int:variable >
    [ \:int:whatever > vec-attach variable [ whatever ]
    , \:int:another > vec-attach variable [ another ]
    ]

type state =
    int

initial-state :state:0

interface \:state:state >
    { new-state int-add state 1
    , standard-out-write int-to-str state
    }

ansi-clear-screen
    "\u{001B}c"

run \:opt str:state-or-uninitialized >
    let state
        state-or-uninitialized
        | :opt str:Absent > ""
        | :opt str:Present :str:initialized > initialized
    :io str:Batch
        [ :io str:Standard-out-write
            strs-flatten
                [ ansi-clear-screen, state, "\nType a sentence to echo: " ]
        , :io str:Standard-in-read-line \:str:line > line
        ]

choice io Future
    | Standard-out-write str
    | Batch vec (io Future)
    | Standard-in-read-line \str > Future

