

choice tree A
    | Leaf A
    | Branch vec (tree A)

tree-size \:tree A:tree >
    tree
    | :tree A:Branch :vec (tree A):subs >
        vec-length subs
    | :tree A:Leaf :A:_ >
        1

choice int-cons-list
    | Empty
    | Cons { head int, tail int-cons-list }

# My docs
# can span multiple lines
#
greet \{ name :str:name } >
    let list
        [ "1", "2", "3" ]
    let another
        vec-attach list
            list
    name
    | "me" >
        "Hello, you!"
    | :str:_ >
        strs-flatten (vec-attach [ "Hello, ", name, "!" ] another)

unfinished
    [ unt-to-str 3
    ]

build-tree \:unt:n >
    int-to-unt (int-add (unt-to-int n) -1)
    | :opt unt:Absent > :tree {}:Leaf {}
    | :opt unt:Present :unt:remaining >
        :tree {}:Branch [ build-tree remaining ]

choice result Ok Err
    | Ok Ok
    | Err Err

closure-requiring-clone-of-capture \:vec int:variable >
    [ \:int:whatever > vec-attach variable [ whatever ]
    , \:int:another > vec-attach variable [ another ]
    ]

test-closure-impl
    vec-walk-from [ 0, 1, 3 ]
        0
        (\:unt:sum, :unt:element >
            :continue-or-exit unt unt:Continue unt-add sum element
        )

type state =
    unt

initial-state :state:0

interface \:state:state >
    { new-state unt-add state 1
    , standard-out-write unt-to-str state
    }

ansi-clear-screen
    "\u{001B}c"

run \:opt str:state-or-uninitialized >
    let state
        state-or-uninitialized
        | :opt str:Absent > ""
        | :opt str:Present :str:initialized > initialized
    :io str:Batch
        [ :io str:Standard-out-write
            strs-flatten
                [ ansi-clear-screen, state, "\nType a sentence to echo: " ]
        , :io str:Standard-in-read-line \:str:line > line
        ]

choice io Future
    | Standard-out-write str
    | Batch vec (io Future)
    | Standard-in-read-line \str > Future

