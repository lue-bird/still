

choice tree A
    | Leaf A
    | Branch vec (tree A)

tree-size \:tree A:tree >
    case tree of
        :tree A:Branch :vec (tree A):subs >
            vec-length subs
        :tree A:Leaf :A:_ >
            1

choice int-cons-list
    | Empty
    | Cons { head int, tail int-cons-list }

(# My docs
#)
greet \{ name :str:name } >
    let list
            [ 1, 2, 3 ]
    let another
            vec-attach list list
    case name of
        "me" >
            "Hello, you!"
        :str:_ >
            strs-flatten [ "Hello, ", name, "!" ]

unfinished
    [ int-to-str 3 ]

build-tree \:int:n >
    case n of
        0 > :tree {}:Leaf {}
        :int:not-0 >
            :tree A:Branch [ build-tree (int-add not-0 -1) ]

choice result Ok Err
    | Ok Ok
    | Err Err

type state =
    int

initial-state :state:0

interface \:state:state >
    { new-state int-add state 1
    , standard-out-write int-to-str state
    }

ansi-clear-screen
    "\u{001B}c"

run \:opt str:state-or-uninitialized >
    let state
            case state-or-uninitialized of
                :opt str:Absent > ""
                :opt str:Present :str:initialized > initialized
    :io str:Io-batch
        [ :io str:Standard-out-write
            strs-flatten
                [ ansi-clear-screen, state, "\\nType a sentence to echo: " ]
        , :io str:Standard-in-read-line \:str:line > line
        ]

choice io Future
    | Standard-out-write str
    | Standard-in-read-line \str > Future

